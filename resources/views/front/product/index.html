<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Product Variations — Demo (click unavailable)</title>
	<!-- Tailwind Play CDN for quick prototyping -->
	<script src="https://cdn.tailwindcss.com"></script>

	<style>
		/* visually mark unavailable but keep clickable */
		.unavailable {
			opacity: 0.55;
		}
		/* optional focus-visible style for keyboard focus */
		.variation-label:focus-visible {
			outline: 2px solid rgba(59,130,246,0.45);
			outline-offset: 2px;
		}
	</style>
</head>
<body class="bg-gray-50 dark:bg-slate-900 min-h-screen p-6">

	<div class="max-w-3xl mx-auto bg-white dark:bg-slate-800 rounded-xl p-6 shadow">
		<h1 class="text-2xl font-semibold mb-4 text-gray-800 dark:text-gray-100">Product variations (demo)</h1>

		<!-- Price / info block -->
		<div id="priceBlock" class="mb-6 p-4 rounded-md bg-gray-100 dark:bg-slate-700">
			<div class="flex items-baseline space-x-4">
				<div>
				<div class="text-2xl font-extrabold text-gray-900 dark:text-gray-100" id="sellingPrice">—</div>
				<div class="text-sm text-gray-500 dark:text-gray-300" id="mrpPrice">—</div>
				</div>
				<div class="ml-auto text-right">
				<div class="text-sm text-green-600 dark:text-green-400 font-medium" id="savings">—</div>
				<div class="text-xs text-gray-500" id="discount">—</div>
				</div>
			</div>
		</div>

		<!-- Variation tab container (will be filled by JS) -->
		<div id="variationTab" class="space-y-4"></div>

		<!-- Add to cart area -->
		<div class="mt-6 flex items-center space-x-4">
			<button id="addToCart" class="px-4 py-2 bg-red-600/90 dark:bg-red-500 text-white rounded-md disabled:opacity-50 disabled:cursor-not-allowed">
				Add to cart
			</button>

			<div id="selectedCombo" class="text-sm text-gray-600 dark:text-gray-300"></div>
		</div>
	</div>

	<script>
		/* ====== productData as provided by you (kept identical) ====== */
		const productData = {
		attributes: [
			{
			id: 2,
			title: "Color",
			slug: "color",
			values: [
				{ id: 64, title: "Midnight", slug: "midnight" },
				{ id: 67, title: "Silver", slug: "silver" },
				{ id: 66, title: "Starlight", slug: "starlight" },
				{ id: 65, title: "Sky Blue", slug: "sky-blue" }
			]
			},
			{
			id: 3,
			title: "RAM",
			slug: "ram",
			values: [
				{ id: 8, title: "16GB", slug: "16gb" },
				{ id: 9, title: "24 GB", slug: "24-gb" }
			]
			},
			{
			id: 4,
			title: "Internal Memory",
			slug: "internal-memory",
			values: [
				{ id: 11, title: "256 GB", slug: "256-gb" },
				{ id: 12, title: "512 GB", slug: "512-gb" }
			]
			}
		],

		combinations: [
			{ id: 1, variation_identifier: "midnight-16gb-256-gb", pricing: [ { country_code: "IN", selling_price_formatted: "97,000", mrp_formatted: "99,000", savings_formatted: "2,000", discount: 2 } ], min_quantity:1, status:1 },
			{ id: 2, variation_identifier: "silver-16gb-256-gb", pricing: [ { country_code: "IN", selling_price_formatted: "97,000", mrp_formatted: "99,000", savings_formatted: "2,000", discount: 2 } ], min_quantity:1, status:1 },
			{ id: 3, variation_identifier: "starlight-16gb-256-gb", pricing: [ { country_code: "IN", selling_price_formatted: "97,000", mrp_formatted: "99,000", savings_formatted: "2,000", discount: 2 } ], min_quantity:1, status:1 },
			{ id: 4, variation_identifier: "sky-blue-16gb-256-gb", pricing: [ { country_code: "IN", selling_price_formatted: "97,000", mrp_formatted: "99,000", savings_formatted: "2,000", discount: 2 } ], min_quantity:1, status:1 },

			{ id: 5, variation_identifier: "midnight-16gb-512-gb", pricing: [ { country_code: "IN", selling_price_formatted: "1,19,000", mrp_formatted: "99,000", savings_formatted: "-20,000", discount: 0 } ], min_quantity:1, status:1 },
			{ id: 6, variation_identifier: "midnight-24-gb-512-gb", pricing: [ { country_code: "IN", selling_price_formatted: "1,39,000", mrp_formatted: "99,000", savings_formatted: "-40,000", discount: 0 } ], min_quantity:1, status:1 },
			{ id: 7, variation_identifier: "sky-blue-24-gb-512-gb", pricing: [ { country_code: "IN", selling_price_formatted: "1,39,000", mrp_formatted: "99,000", savings_formatted: "-40,000", discount: 0 } ], min_quantity:1, status:1 }
		]
		};

		/* ====== Utility helpers ====== */

		const combosByIdentifier = {};
		productData.combinations.forEach(c => combosByIdentifier[c.variation_identifier] = c);

		function identifierToSlugs(identifier) {
		return identifier.split('-');
		}

		function initialSelection() {
		if (productData.combinations.length === 0) return {};
		const first = productData.combinations[0].variation_identifier;
		// robust parse (re-usable)
		return parseIdentifierToMap(first);
		}

		function parseIdentifierToMap(identifier) {
		const map = {};
		const tokens = identifier.split('-');
		let i = 0;
		for (const attr of productData.attributes) {
			let matched = null;
			for (let take = 1; take <= tokens.length - i; take++) {
			const candidate = tokens.slice(i, i + take).join('-');
			if (attr.values.some(v => v.slug === candidate)) {
				matched = candidate;
				i += take;
				break;
			}
			}
			if (!matched) matched = attr.values[0].slug;
			map[attr.slug] = matched;
		}
		return map;
		}

		function findCombinationForSelection(selection) {
		const slugs = productData.attributes.map(a => selection[a.slug]).filter(Boolean);
		if (slugs.length !== productData.attributes.length) return null;
		const identifier = slugs.join('-');
		return combosByIdentifier[identifier] || null;
		}

		function isValueValid(attrSlug, valueSlug, partialSelection) {
		return productData.combinations.some(c => {
			const map = combinationToMap(c);
			for (const [k, v] of Object.entries(partialSelection)) {
			if (map[k] !== v) return false;
			}
			return map[attrSlug] === valueSlug;
		});
		}

		function combinationToMap(c) {
		return parseIdentifierToMap(c.variation_identifier);
		}

		/* ====== New: pick best combo that includes a chosen attribute value ====== */
		function chooseBestComboForAttributeValue(attrSlug, valueSlug, currentPartial) {
		// find combos that have this attribute = valueSlug
		const candidates = productData.combinations
			.map(c => ({ combo: c, map: combinationToMap(c) }))
			.filter(x => x.map[attrSlug] === valueSlug);

		if (candidates.length === 0) return null;

		// score by how many attributes match currentPartial (higher score preferred)
		let best = candidates[0];
		let bestScore = -1;
		for (const c of candidates) {
			let score = 0;
			for (const [k, v] of Object.entries(currentPartial)) {
			if (c.map[k] && c.map[k] === v) score++;
			}
			// prefer combos that match more of currentPartial; tie-breaker: first found
			if (score > bestScore) {
			bestScore = score;
			best = c;
			}
		}
		return best.map;
		}

		/* ====== Renderers & UI logic ====== */

		const variationTab = document.getElementById('variationTab');
		const priceBlock = {
		sellingPrice: document.getElementById('sellingPrice'),
		mrpPrice: document.getElementById('mrpPrice'),
		savings: document.getElementById('savings'),
		discount: document.getElementById('discount'),
		};
		const addToCartBtn = document.getElementById('addToCart');
		const selectedComboEl = document.getElementById('selectedCombo');

		let currentSelection = initialSelection();

		function renderVariationTab() {
		variationTab.innerHTML = '';
		productData.attributes.forEach((attribute, attrIndex) => {
			const wrapper = document.createElement('div');

			// title
			const title = document.createElement('h3');
			title.className = 'text-sm font-semibold mb-2 text-gray-600 dark:text-gray-500';
			title.textContent = attribute.title;
			wrapper.appendChild(title);

			// values container
			const valuesContainer = document.createElement('div');
			valuesContainer.className = 'flex flex-wrap space-x-2';
			attribute.values.forEach((value, valueIndex) => {
			const group = document.createElement('div');
			group.className = 'group';

			// input radio (keep enabled so label click toggles normally)
			const input = document.createElement('input');
			input.type = 'radio';
			input.id = `attr${attrIndex}${valueIndex}`;
			input.name = `variation-${attribute.slug}`;
			input.value = value.slug;
			input.className = 'hidden peer';
			if (currentSelection[attribute.slug] === value.slug) input.checked = true;

			// label (click handler will implement "intent")
			const label = document.createElement('label');
			label.setAttribute('for', input.id);
			label.tabIndex = 0;
			label.className = [
				'inline-block',
				'rounded-full',
				'cursor-pointer',
				'text-gray-700',
				'dark:text-gray-200',
				'bg-gray-200',
				'dark:bg-gray-600',
				'border-2',
				'border-gray-200',
				'dark:border-gray-600',
				'hover:bg-gray-100',
				'dark:hover:bg-gray-700',
				'peer-checked:bg-gray-100',
				'dark:peer-checked:bg-gray-800',
				'peer-checked:border-red-700',
				'dark:peer-checked:border-red-600',
				'peer-checked:text-gray-900',
				'dark:peer-checked:text-gray-100',
				'px-2',
				'py-1',
				'mb-2',
				'mr-2',
				'transition',
				'duration-150',
				'variation-label'
			].join(' ');

			label.innerHTML = `<p class="text-sm font-medium">${value.title}</p>`;

			group.appendChild(input);
			group.appendChild(label);
			valuesContainer.appendChild(group);

			// normal change handler (when clicking available option)
			input.addEventListener('change', (e) => {
				if (e.target.checked) {
				// set selection for this attribute then try to keep others if possible
				const best = chooseBestComboForAttributeValue(attribute.slug, value.slug, currentSelection) || {};
				// if chooseBest returns a map, set selection to that map; otherwise just set the attribute
				if (Object.keys(best).length) currentSelection = { ...best };
				else currentSelection[attribute.slug] = value.slug;
				updateUI();
				}
			});

			// label click — handle "intent" even when the value currently looks unavailable.
			label.addEventListener('click', (ev) => {
				ev.preventDefault();
				// find best combo that includes this clicked value while trying to preserve other selections
				const bestMap = chooseBestComboForAttributeValue(attribute.slug, value.slug, currentSelection);
				if (bestMap) {
				currentSelection = { ...bestMap };
				} else {
				// fallback: just set the attribute and let autoFix fill others
				currentSelection[attribute.slug] = value.slug;
				}
				updateUI();
				// programmatically mark the radio as checked for accessibility/peer styles
				const inputEl = document.getElementById(`attr${attrIndex}${valueIndex}`);
				inputEl.checked = true;
			});

			// keyboard activation
			label.addEventListener('keydown', (ev) => {
				if (ev.key === 'Enter' || ev.key === ' ') {
				ev.preventDefault();
				label.click();
				}
			});
			});

			wrapper.appendChild(valuesContainer);
			variationTab.appendChild(wrapper);
		});

		updateUI();
		}

		// update labels & styles & price panel
		function updateUI() {
		productData.attributes.forEach((attribute, attrIndex) => {
			attribute.values.forEach((value, valueIndex) => {
			const input = document.getElementById(`attr${attrIndex}${valueIndex}`);
			const label = input.nextElementSibling;

			// build partial selection excluding the attribute being tested
			const partial = {};
			for (const [k, v] of Object.entries(currentSelection)) {
				if (k !== attribute.slug && v) partial[k] = v;
			}

			// determine if value appears in ANY combo compatible with partial
			const valid = isValueValid(attribute.slug, value.slug, partial);

			if (!valid) {
				// visually mark unavailable but DO NOT disable -> user can still click
				label.classList.add('unavailable');
				label.setAttribute('title', 'Not available with current selection (click to switch)');
				// ensure it's not checked unless currentSelection specifically set it (we'll set checked below)
				input.checked = currentSelection[attribute.slug] === value.slug;
			} else {
				label.classList.remove('unavailable');
				label.removeAttribute('title');
				input.checked = currentSelection[attribute.slug] === value.slug;
			}
			});
		});

		// update selected combination display & price
		const combo = findCombinationForSelection(currentSelection);
		if (combo) {
			const p = combo.pricing && combo.pricing[0] ? combo.pricing[0] : null;
			priceBlock.sellingPrice.textContent = p ? (p.selling_price_formatted || p.selling_price || '—') : '—';
			priceBlock.mrpPrice.textContent = p ? `MRP: ${p.mrp_formatted || p.mrp || '—'}` : '';
			priceBlock.savings.textContent = p ? (p.savings_formatted || '') : '';
			priceBlock.discount.textContent = p ? (p.discount ? `${p.discount}% off` : '') : '';
			addToCartBtn.disabled = false;
			selectedComboEl.textContent = `Selected: ${combo.variation_identifier} (id: ${combo.id})`;
		} else {
			priceBlock.sellingPrice.textContent = '—';
			priceBlock.mrpPrice.textContent = '';
			priceBlock.savings.textContent = '';
			priceBlock.discount.textContent = '';
			addToCartBtn.disabled = true;
			selectedComboEl.textContent = 'Please select a valid combination';
		}

		// ensure radio DOM reflects selection
		productData.attributes.forEach((attribute, attrIndex) => {
			attribute.values.forEach((value, valueIndex) => {
			const input = document.getElementById(`attr${attrIndex}${valueIndex}`);
			input.checked = currentSelection[attribute.slug] === value.slug;
			});
		});
		}

		// initial render
		renderVariationTab();

		// Add to cart demo
		addToCartBtn.addEventListener('click', () => {
		const combo = findCombinationForSelection(currentSelection);
		if (!combo) {
			alert('Select a valid combination first');
			return;
		}
		alert(`Adding combination id ${combo.id} (${combo.variation_identifier}) to cart — demo`);
		});

		// ensure initial selection is valid on load
		window.addEventListener('load', () => {
		if (!findCombinationForSelection(currentSelection)) {
			currentSelection = combinationToMap(productData.combinations[0]);
		}
		updateUI();
		});

	</script>
</body>
</html>
